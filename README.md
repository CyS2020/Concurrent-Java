### 八大核心技术
### 一、实现多线程的正确姿势
#### 实现多线程的方法？
- 方法一：实现Runnable接口；方法二：继承Thread类；  通常我们优先选择方法一。
- 实现Runnable接口好在哪里？继承Thread类是不推荐的，因为它有以下的一些缺点：
  - 1. 从代码架构角度：具体的任务（run方法）应该和“创建和运行线程的机制（Thread类）”解耦，用runnable对象可以实现解耦。
  - 2. 使用继承Thread的方式的话，那么每次想新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大
  （比如重头开始创建一个线程、执行完毕以后再销毁等。如果线程的实际工作内容，也就是run()函数里只是简单的打印一行文字的话，那么可能线程的实际工作内容还不如损耗来的大）。
  如果使用Runnable和线程池，就可以大大减小这样的损耗。
  - 3. 继承Thread类以后，由于Java语言不支持双继承，这样就无法再继承其他的类，限制了可扩展性。
- 两种方法的本质对比
  - 方法一和方法二，也就是“实现Runnable接口并传入Thread类”和“继承Thread类然后重写run()”在实现多线程的本质上，并没有区别，
  都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源：
  - 方法一：最终调用target.run()；方法二：run()整个都被重写
```
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
 ```
  
#### 答题思路，以下5点：
- 1. 从不同的角度看，会有不同的答案。
- 2. 典型答案是两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；
- 3. 但是，我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现
其实那两种本质都是一样的，run方法的代码如下：
```
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
 ```
- 4. 方法一和方法二，也就是“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”在实
现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别
在于run()方法的内容来源：
方法一：最终调用target.run();
方法二：run()整个都被重写
- 5. 然后具体展开说其他方式；
还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源码，从没有逃出过
本质，也就是实现Runnable接口和继承Thread类。
- 6. 结论:我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实
现，第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnable实例传
给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是它们的本
质都逃不出刚才所说的范围。
以上这种描述比直接回答一种、两种、多种都更准确。
